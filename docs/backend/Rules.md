A Database rule is a way to enforce certain attributes about the data in a database. A rule prevents a change in the database if the change would result in the a rule being false.
Some example rules:
- The totals of all cost columns in the purchases table exceeding $10000
- No entries in the expense's table with a data past the project end date
- All entries in the travel table are through approved carriers

This is accomplished through some meta functions within the postgres database and will create/update/remove the rules based on the entries of tables in under the *rules* schema
![Rules_ERD](docs/backend/Rules_ERD.png)
## How Rules Work
If you want to create/modify/remove a rule from the database you can do so with entries in the following tables:

- *rules.Rule*
- *rules.Conditions*
- *rules.Actions*
- *rules.Selectors*

Each table is used to create complex rules based on the entries in them.
The following sections give an overview of what each of the tables are, and what their purpose is.

### rules.Rules
The Rules table is a top level table that contains the rules that are currently applied to the database. The Rules table has the following schema:

| RuleID                | Name                          | Description,              | Trigger                                                                      | Table                                  | Enabled                        |
| --------------------- | ----------------------------- | ------------------------- | ---------------------------------------------------------------------------- | -------------------------------------- | ------------------------------ |
| ID number of the rule | The user set name of the rule | A description of the rule | An autogenerated column with the associated SQL function's name for the rule | The table that the rule is applied to. | Bool, Enabled or Disabled rule |

Entries in this table are used to represent the rule as a whole and provide user supplied information on what the rule is used for. This is also where you can enable or disable the rule from running. The Trigger field is autogenerated for the rule and should not be manually inputted by the user. The table column is used to select which table the rule will be run automatically for whenever the table is updated. 

### rules.Selectors
The Selectors table is used to select data when evaluating rule. It has the following schema

| SID             | Schema                 | Table                         | Target                                    | Aggregator                               | Type                                     |
| --------------- | ---------------------- | ----------------------------- | ----------------------------------------- | ---------------------------------------- | ---------------------------------------- |
| The Selector ID | The Schema of the data | The table containing the data | The column of the data, Or a static value | How to aggregate the data for comparison | The postgres type of the data to be used |

The entries in the selectors table have two different types:
1. Database Selectors: Selectors that query other data in the database to select
2. Static Selectors: Selectors that return static values

Both types can be used for rules and will allow the rules system to get a evaluate conditions on the database.
#### Static Selectors
Static selectors are useful for creating rules that compare database entries with some value, like creating a rule that prevents the sum of some tables column from exceeding an specified amount (ie: The totals of all cost columns in the purchases table exceeding $10000). To use a static selector enter the static value in the Target column, and leave Schema and Table null

#### Database Selectors
Database Selectors are used for selecting data from the database to use in rule evaluation. These types of selectors require that the schema, table, and column be selected from some existing table within the database, with the column's name in the target field. 

In both cases the type field indicates the PG type that the data should be cast to during rule evaluation.
> *IMPORTAINT:* During rule evaluation the type specified in the type field should be compatible with the type specified that will be compared against in the conditions step of the process. This means that a rule will fail to evaluate if the two types are not compatible under the comparison operator (ie: using a greater than `>` operator on types `money` and `float` will fail. Refer to the postgres documentation when preforming comparisons on different types)

The data that is collected during the rule evaluation should match, or be valid with a postgres CAST() call, with the type defined in this field.

The Aggregator field should be a valid SQL Aggregation keyword to be used to aggregate the data during rule evaluation. 
> *Note:* For static selectors generally `MAX` is the aggregation operator that should be used



### rules.Conditions

The Conditions table is used to perform a conditional operator on two selectors. The Schema for the Conditions table follows:

| CID                | LeftSID                                             | Operator                                                                                   | RightSID                                             |
| ------------------ | --------------------------------------------------- | ------------------------------------------------------------------------------------------ | ---------------------------------------------------- |
| The Condition's ID | The SID of the Selector on the left of the operator | A valid SQL conditional operator that evaluates to a boolean value. (ie: <, >, =, !=, ect) | The SID of the Selector on the right of the operator |
The entries in the conditions table are used to evaluate conditional statements on selectors, These are the core of the rules systems and are what actually decides if a rule has been violated during evaluation.


### rules.Actions
Actions are what tie the different parts of a rule together. Their Schema is as follows:

| RuleID                        | CID                                     | Conjunction                                                                               |
| ----------------------------- | --------------------------------------- | ----------------------------------------------------------------------------------------- |
| The ID of the associated rule | The id of the condition to be evaluated | How the result of the condition should be conjoined with any other actions. (ie: AND, OR) |

Actions tie conditions to rules and specify how those conditions should be conjoined. Multiple actions can be combined for a single rule to evaluate several conditions.

## Example

The following shows a working example for how to create a rule for the database.

 > Rule: The totals of all amount columns in the public.purchases table exceeding $10000
 

### Create Rule
First we will create the rule that will be used for the database

SQL:
```sql
INSERT INTO rules."Rule"(
	"RuleID", "Name", "Description", "Trigger", "Table", "Enabled")
VALUES (
	1, 
	'Max Purchace Amount',
	'The totals of all amount columns in the purchases table exceeding $10000',
	'',
	'public.purchases', 
	TRUE
);
```

### Create Selectors
For this rule we need two selectors
1. A selector that totals the purchase's amount column
2. A selector that selects a static value of $10000

SQL:
```sql
INSERT INTO rules."Selectors"("SID", "Schema", "Table", "Target", "Aggregator", "Type")
VALUES 
	(1, 'public', 'purchases', 'amount', 'SUM', 'money'),
	(2, NULL,     NULL,         10000,   'MAX', 'money');
```

### Create Conditions
For this rule we only need one condition comparing the two selectors created above:

SQL:
```sql
INSERT INTO rules."Conditions"("CID", "LeftSID", "Operator", "RightSID")
	VALUES (1, 1, '<', 2);
```


### Create Actions
We only have one action to make, once we add it to the database the rule will be applied

SQL:
```sql
INSERT INTO rules."Actions"("RuleID", "CID", "Conjunction")
	VALUES (1, 1, 'AND');
```

The rule should now be in effect for the database!